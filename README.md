# Вариант №6

Разработать ассемблер и интерпретатор для учебной виртуальной машины (УВМ).

## Спецификация УВМ

### Загрузка константы

| Поле | Биты     | Описание |
|------|----------|-----------|
| A    | 0—5      | Код операции = 45 |
| B    | 6—33     | Константа |
| C    | 34—38    | Адрес регистра |

Размер команды: 5 байт.  
Операнд: поле B.  
Результат: регистр по адресу, которым является поле C.

Тест (A=45, B=967, C=25):  
`0xED, 0xF1, 0x00, 0x00, 0x64`

### Чтение значения из памяти

| Поле | Биты     | Описание |
|------|----------|-----------|
| A    | 0—5      | Код операции = 61 |
| B    | 6—10     | Адрес регистра-приёмника |
| C    | 11—15    | Адрес регистра-источника |

Размер команды: 5 байт.  
Операнд: значение в памяти по адресу, которым является регистр по адресу, которым является поле C.  
Результат: регистр по адресу, которым является поле B.

Тест (A=61, B=0, C=12):  
`0x3D, 0x60, 0x00, 0x00, 0x00`

### Запись значения в память

| Поле | Биты     | Описание |
|------|----------|-----------|
| A    | 0—5      | Код операции = 34 |
| B    | 6—10     | Адрес регистра-источника |
| C    | 11—37    | Адрес в памяти |

Размер команды: 5 байт.  
Операнд: регистр по адресу, которым является поле B.  
Результат: значение в памяти по адресу, которым является поле C.

Тест (A=34, B=25, C=234):  
`0x62, 0x56, 0x07, 0x00, 0x00`

### Унарная операция: sqrt()

| Поле | Биты     | Описание |
|------|----------|-----------|
| A    | 0—5      | Код операции = 5 |
| B    | 6—10     | Адрес регистра-приёмника |
| C    | 11—15    | Адрес регистра-источника |

Размер команды: 5 байт.  
Операнд: регистр по адресу, которым является поле C.  
Результат: значение в памяти по адресу, которым является регистр по адресу, которым является поле B.

Тест (A=5, B=3, C=24):  
`0xC5, 0xC0, 0x00, 0x00, 0x00`

---

## Этап 1. Перевод программы в промежуточное представление

**Цель:** создать CLI-приложение ассемблера. Реализовать разбор текстового представления команд и трансляцию в промежуточное представление.

**Требования:**

1. Ассемблер должен принимать на вход аргументы командной строки:
   - Путь к исходному файлу с текстом программы.
   - Путь к двоичному файлу-результату.
   - Режим тестирования.

2. Спроектировать человекочитаемый язык ассемблера, используя формат JSON. Поддержать все команды спецификации УВМ.

3. Описать в документации (например, в README.md) спроектированный язык ассемблера.

4. Реализовать транслятор, который язык ассемблера преобразует во внутреннее представление (например, список кортежей, объектов или словарей).

5. (только для данного этапа) В режиме тестирования вывести на экран внутреннее представление ассемблированной программы в формате полей и значений, как в тесте из спецификации УВМ.

6. Создать программу для тестов, приведенных в спецификации УВМ. Продемонстрировать, что ассемблер генерирует идентичные последовательности полей и их значений.

7. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.

---

## Этап 2. Формирование машинного кода

**Цель:** реализовать логику преобразования команд в их двоичное представление.

**Требования:**

1. Реализовать транслятор из промежуточного в машинное представление.
2. Записать результат ассемблирования в двоичный выходной файл.
3. Вывести на экран число ассемблированных команд.
4. В режиме тестирования вывести результат ассемблирования на экран в байтовом формате, как в тесте из спецификации УВМ.
5. Создать файл на языке ассемблера, результат трансляции которого соответствует всем тестовым байтовым последовательностям из спецификации УВМ.
6. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.

---

## Этап 3. Интерпретатор и операции с памятью

**Цель:** создать цикл интерпретации, реализовать модель памяти УВМ и выполнить базовые команды.

**Требования:**

1. Интерпретатор должен принимать на вход аргументы командной строки:
   - Путь к бинарному файлу с ассемблированной программой.
   - Путь к файлу, куда будет сохранен дамп памяти после выполнения программы.
   - Диапазон адресов памяти для вывода дампа.

2. Для дампа с содержимым памяти должен использоваться формат XML.

3. Реализовать модель памяти УВМ (например, в виде массивов). Память команд и память данных должны быть разделены.

4. Реализовать основной цикл интерпретатора: чтение команды из бинарного файла, перевод команды в промежуточное представление, выполнение.

5. Реализовать команды загрузки константы, а также чтение и запись в память.

6. Написать и выполнить тестовую программу, которая копирует массив с одного адреса на другой, чтобы проверить корректность работы.

7. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.

---

## Этап 4. Реализация арифметико-логического устройства (АЛУ)

**Цель:** завершить реализацию интерпретатора, добавив поддержку вычислительных операций.

**Требования:**

1. Реализовать выполнение команды `sqrt()`.
2. Для реализованной команды написать и выполнить тестовую программу, которая демонстрирует корректные вычисления с сохранением результата в память для проверки.
3. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.

---

## Этап 5. Выполнение тестовой задачи

**Цель:** использовать разработанные ассемблер и интерпретатор для решения тестовой задачи.

**Требования:**

1. Написать, скомпилировать и исполнить программу по тестовой задаче: выполнить извлеченную команду `sqrt()` над вектором длины 10. Результат записать в исходный вектор.
2. Создать три примера программ с вычислениями над различными данными. Продемонстрировать, что дамп памяти соответствует требованиям задачи.
3. Результат выполнения этапа сохранить в репозиторий стандартно оформленным коммитом.